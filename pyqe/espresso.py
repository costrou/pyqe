"""
An assistant to QE (Quantum Espresso) via python
currently my aim is to support the fortran syntax

See
http://www.quantum-espresso.org/wp-content/uploads/Doc/pw_user_guide/node8.html
for details on the input format to PW

'!#' - fortran comment characters


"""
from pyqe.cards import AtomicSpecies, AtomicPositions, KPoints, CellParameters
from pyqe.namelists import Control, System, Electrons, Ions, Cell

class QE:
    """
    Quantum Espresso Main Class

    From this class you can:
     - initialize the input
     - create inputfile
     - run pw.x
    """

    def __init__(self):
        self.control = Control()
        self.system = System()
        self.electrons = Electrons()
        self.ions = Ions()
        self.cell = Cell()

        self.atomic_species = AtomicSpecies()
        self.atomic_positions = AtomicPositions()
        self.k_points = KPoints()
        self.cell_parameters = CellParameters()
        # Not Implemented (Card not a class)
        #self.occupations = Card("OCCUPATIONS")
        #self.constrains = Card("CONTRAINTS")
        #self.atomicforces = Card("ATOMIC_FORCES")

    def to_string(self, header=True):
        qe_str = ""

        if (header == True):
            qe_str += "! File Autogenerated from Python QE\n"

        ## NameLists
        qe_str += self.control.to_string()
        qe_str += self.system.to_string()
        qe_str += self.electrons.to_string()
        qe_str += self.ions.to_string()
        qe_str += self.cell.to_string()

        ## Cards
        qe_str += str(self.atomic_species)

        # Only needed if calculations is not
        # 'band' or 'nscf'
        if self.control.get_current_value("calculation") not in ["nscf", "bands"]:
            qe_str += str(self.atomic_positions)

        qe_str += str(self.k_points)

        # Only needed if unitcell is not defined
        # By ibrav
        if self.system.get_current_value("ibrav") == 0:
            qe_str += str(self.cell_parameters)

        # Not Implemented
        # qe_str += str(self.occupations)
        # qe_str += str(self.contraints)
        # qe_str += str(self.atomic_forces)
        return qe_str

    def parse_output(self, outstr):
        """
        Routine I am making currently just for my homework
        but this routine will be expanded. (hack currently)

        Retruns a dictionary of interesting values
        Uses regular expressions extensiely
        """
        results = {}

        # Name | Regular Expression
        values = {
            "total energy": ("!\s+total energy\s+=\s+([+-]\d+\.\d+) Ry", float),
            "lattice index": ("bravais-lattice index\s+=\s+(\d+)", float),
            "lattice parameter": ("lattice parameter \(alat\)\s+=\s+(\d+\.\d+) a\.u\.", float),
            "volume": ("unit-cell volume\s+=\s+(\d+\.\d+) \(a\.u\.\)\^3", float),
            "number electrons": ("number of electrons\s+=\s+(\d+\.\d+)", float),
            "cell dimensions": ("\s+celldm\(1\)=\s+(\d+\.\d+)\s+celldm\(2\)=\s+(\d+\.\d+)\s+celldm\(3\)=\s+(\d+\.\d+)\s+celldm\(4\)=\s+(\d+\.\d+)\s+celldm\(5\)=\s+(\d+\.\d+)\s+celldm\(6\)=\s+(\d+\.\d+)", float)
        }

        import re
        for key, info in values.items():
            regex, regex_type = info
            mat = re.search(regex, outstr)
            if mat:
                results.update({key: [regex_type(_) for _ in mat.groups()]})
        return results

    def to_file(self, filename, input_format="fortran"):
        """
        Writes QE configuration to <filename>
        in format specified. Currently only supports
        the Fortran style.
        """
        with open(filename, "w") as qefile:
            qefile.write(self.to_string())

    def run(self, infile="", outfile="", errfile=""):
        """
        Runs QE pw.x.

        If stdin, stdout, stderr filenames are not defined
        no file is created for the given input or output.

        If 'in_filename' is defined the program will run from the
        file rather than stdin via '-i'.

        Notice:
        QE will still create the save files in the directory
        specified by 'outfile' in control namelist
        """
        from subprocess import Popen, PIPE

        if infile != "":
            self.to_file(infile)

            pw_command = ["pw.x", '-i', infile]
            proc = Popen(pw_command, stdout=PIPE, stderr=PIPE)
            pw_output = proc.communicate()
        else:
            pw_input = self.to_string()

            pw_command = ["pw.x"]
            proc = Popen(pw_command, stdin=PIPE, stdout=PIPE, stderr=PIPE)
            pw_output = proc.communicate(pw_input.encode())

        proc.wait()
        pw_out = pw_output[0].decode()
        pw_err = pw_output[1].decode()

        if outfile != "":
            with open(outfile, "w") as out_file:
                out_file.write(pw_out)

        if errfile != "":
            with open(errfile, "w") as err_file:
                err_file.write(pw_err)

        return self.parse_output(pw_out)

    def validate(self):
        """
        Each Namelist and Cards will validate its contents.
        Sometimes they will need access to global information.
        (not sure how to handle this yet)
        """
        self.control.validate(self)
        self.system.validate(self)
        self.electrons.validate(self)
        self.ions.validate(self)
        self.cell.validate(self)

        self.atomic_species.validate()
        self.atomic_positions.validate()
        self.k_points.validate()
        self.cell_parameters.validate()
        # Not Implemented
        # self.occupations.validate()
        # self.constrains.validate()
        # self.atomicforces.validate()


