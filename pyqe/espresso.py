"""
An assistant to QE (Quantum Espresso) via python
currently my aim is to support the fortran syntax

See
http://www.quantum-espresso.org/wp-content/uploads/Doc/pw_user_guide/node8.html
for details on the input format to PW

'!#' - fortran comment characters


"""
from pyqe.cards import AtomicSpecies, AtomicPositions, KPoints, CellParameters
from pyqe.namelists import Control, System, Electrons, Ions, Cell

class QE:
    """
    Quantum Espresso Main Class

    From this class you can:
     - initialize the input
     - create inputfile
     - run pw.x
    """

    def __init__(self, qe_keypairs):
        self.control = Control()
        self.system = System()
        self.electrons = Electrons()
        self.ions = Ions()
        self.cell = Cell()

        self.atomic_species = AtomicSpecies()
        self.atomic_positions = AtomicPositions()
        self.k_points = KPoints()
        self.cell_parameters = CellParameters()
        # Not Implemented (Card not a class)
        #self.occupations = Card("OCCUPATIONS")
        #self.constrains = Card("CONTRAINTS")
        #self.atomicforces = Card("ATOMIC_FORCES")

        self.namelist_asoc = {
            "control": self.control,
            "system": self.system,
            "electrons": self.electrons,
            "ions": self.ions,
            "cell": self.cell
        }

        self.add_keypairs_to_namespace(qe_keypairs)

    def add_keypairs_to_namespace(self, qe_keypairs):
        """
        Adds the respective keys to each namelist
        """
        for name, keypairs in qe_keypairs.items():
            namelist = self.namelist_asoc.get(name.lower())
            if namelist:
                namelist.add_keypairs(keypairs)
            else:
                error_str = "{0} is not valid namelist"
                raise Exception(error_str.format(name))

    def to_string(self, header=True):
        qe_str = ""

        if (header == True):
            qe_str += "! File Autogenerated from Python QE\n"

        ## NameLists
        qe_str += self.control.to_string()
        qe_str += self.system.to_string()
        qe_str += self.electrons.to_string()
        qe_str += self.ions.to_string()
        qe_str += self.cell.to_string()

        ## Cards
        qe_str += str(self.atomic_species)

        # Only needed if calculations is not
        # 'band' or 'nscf'
        if self.control.get_current_value("calculation") not in ["nscf", "bands"]:
            qe_str += str(self.atomic_positions)

        qe_str += str(self.k_points)

        # Only needed if unitcell is not defined
        # By ibrav
        if self.system.get_current_value("ibrav") == 0:
            qe_str += str(self.cell_parameters)

        # Not Implemented
        # qe_str += str(self.occupations)
        # qe_str += str(self.contraints)
        # qe_str += str(self.atomic_forces)
        return qe_str

    def parse_output(self, outstr):
        """
        Routine I am making currently just for my homework
        but this routine will be expanded. (hack currently)

        Retruns a dictionary of interesting values
        Uses regular expressions extensiely
        """
        import re

        # Extract the information from the header
        header_end = outstr.find("Self-consistent Calculation")
        header_str = outstr[:header_end]

        scf_block_begin = outstr.find("Self-consistent Calculation")
        scf_block_end = outstr.find("convergence has been achieved in")
        scf_block_str = outstr[scf_block_begin:scf_block_end]

        bfgs_steps = []
        if self.control.get_current_value('calculation') in ['relax', 'vc-relax']:
            bfgs_begin = outstr.find("BFGS Geometry Optimization")
            bfgs_end = outstr.find("End of BFGS Geometry Optimization")
            bfgs_str = outstr[bfgs_begin:bfgs_end]

            bfgs_block_begin = bfgs_str.find("number of scf cycles")
            bfgs_block_end = bfgs_str.find("Writing output data file")

            if bfgs_block_begin == -1:
                final_begin = outstr.find("Final energy")
                final_end = outstr.find("End final coordinates")
                final_str = outstr[final_begin:final_end]
                bfgs_steps.append((scf_block_str, final_str))
            else:
                bfgs_block_str = bfgs_str[bfgs_block_begin:bfgs_block_end]
                bfgs_steps.append((scf_block_str, bfgs_block_str))

                current_pos = bfgs_block_end + 10 #HACK fix!!!!

                while True:
                    scf_block_begin = bfgs_str[current_pos:].find("Self-consistent Calculation")
                    scf_block_end = bfgs_str[current_pos:].find("convergence has been achieved in")
                    scf_block_str = bfgs_str[current_pos:][scf_block_begin:scf_block_end]

                    bfgs_block_begin = bfgs_str[current_pos:].find("number of scf cycles")
                    bfgs_block_end = bfgs_str[current_pos:].find("Writing output data file")

                    if bfgs_block_begin == -1:
                        final_begin = outstr.find("Final enthalpy")
                        final_end = outstr.find("End final coordinates")
                        final_str = outstr[final_begin:final_end]
                        bfgs_steps.append((scf_block_str, final_str))
                        break

                    bfgs_block_str = bfgs_str[current_pos:][bfgs_block_begin:bfgs_block_end]
                    bfgs_steps.append((scf_block_str, bfgs_block_str))

                    current_pos += bfgs_block_end + 10 #HACK fix!!!!
        else:
            bfgs_steps.append((scf_block_str, ""))

        footer_begin = outstr.find("init_run")
        footer_str = outstr[footer_begin:]

        results = {}

        ## Begin parsing the blocked strings
        # Parse the header string for needed values
        header_values = {
            "lattice index": ("bravais-lattice index\s+=\s+(\d+)", float),
            "lattice parameter": ("lattice parameter \(alat\)\s+=\s+(\d+\.\d+) a\.u\.", float),
            "volume": ("unit-cell volume\s+=\s+(\d+\.\d+) \(a\.u\.\)\^3", float),
            "number electrons": ("number of electrons\s+=\s+(\d+\.\d+)", float),
        }

        header = {}
        for key, (regex, _type) in header_values.items():
            result = re.search(regex, header_str)
            if result:
                header.update({key: result.group(1)})

        results.update({"header": header})

        # Parse the results of calculation
        total_energy_regex = re.compile("!\s+total energy\s+=\s+([+-]\d+\.\d+) Ry")
        volume_regex = re.compile("new unit-cell volume\s=\s+(\d+\.\d+) a\.u\.\^3")
        lattice_regex = re.compile("CELL_PARAMETERS.*\s+([-+]?\d+\.\d+)\s+([-+]?\d+\.\d+)\s+([-+]?\d+\.\d+)\s+\s+([-+]?\d+\.\d+)\s+([-+]?\d+\.\d+)\s+([-+]?\d+\.\d+)\s+\s+([-+]?\d+\.\d+)\s+([-+]?\d+\.\d+)\s+([-+]?\d+\.\d+)")
        ion_position_regex = re.compile("([A-Z][a-z]?)\s+([+-]?\d+\.\d+)\s+([+-]?\d+\.\d+)\s+([+-]?\d+\.\d+)")

        calculation = {}
        iterations = []
        for scf_block, bgfs_block in bfgs_steps:
            result = total_energy_regex.search(scf_block)
            total_energy = float(result.group(1))

            volume = None
            lattice = None
            if self.control.get_current_value('calculation') == 'vc-relax':
                result = volume_regex.search(bgfs_block)
                volume = float(result.group(1))

                result = new_lattice_regex.search(bgfs_block)
                lattice = [float(_) for _ in result.groups()]
                lattice = [lattice[0:3],
                           lattice[3:6],
                           lattice[6:9]]

            ion_positions = None
            if self.control.get_current_value('calculation') in ['relax', 'vc-relax']:
                ion_positions = [[_[0], float(_[1]), float(_[2]), float(_[3])] \
                                     for _ in ion_position_regex.findall(bgfs_block)]

            iterations.append({"total energy": total_energy,
                               "volume": volume,
                               "lattice": lattice,
                               "ion positions": ion_positions})

        calculation.update({"iterations": iterations})
        calculation.update({"total energy": iterations[-1]['total energy']})
        calculation.update({"volume": iterations[-1]['volume']})
        calculation.update({"lattice": iterations[-1]['lattice']})
        calculation.update({"ion positions": iterations[-1]['ion positions']})

        results.update({"calculation": calculation})

        print(results)

        return results

    def to_file(self, filename, input_format="fortran"):
        """
        Writes QE configuration to <filename>
        in format specified. Currently only supports
        the Fortran style.
        """
        with open(filename, "w") as qefile:
            qefile.write(self.to_string())

    def run(self, infile="", outfile="", errfile=""):
        """
        Runs QE pw.x.

        If stdin, stdout, stderr filenames are not defined
        no file is created for the given input or output.

        If 'in_filename' is defined the program will run from the
        file rather than stdin via '-i'.

        Notice:
        QE will still create the save files in the directory
        specified by 'outfile' in control namelist
        """
        from subprocess import Popen, PIPE

        prefix = []
        postfix = []

        if infile != "":
            self.to_file(infile)

            pw_command = prefix + ["pw.x", '-i', infile] + postfix
            proc = Popen(pw_command, stdout=PIPE, stderr=PIPE)
            pw_output = proc.communicate()
        else:
            pw_input = self.to_string()

            pw_command = prefix + ["pw.x"] + postfix
            proc = Popen(pw_command, stdin=PIPE, stdout=PIPE, stderr=PIPE)
            pw_output = proc.communicate(pw_input.encode())

        proc.wait()
        pw_out = pw_output[0].decode()
        pw_err = pw_output[1].decode()

        if outfile != "":
            with open(outfile, "w") as out_file:
                out_file.write(pw_out)

        if errfile != "":
            with open(errfile, "w") as err_file:
                err_file.write(pw_err)

        return self.parse_output(pw_out)

    def validate(self):
        """
        Each Namelist and Cards will validate its contents.
        Sometimes they will need access to global information.
        (not sure how to handle this yet)
        """
        self.control.validate(self)
        self.system.validate(self)
        self.electrons.validate(self)
        self.ions.validate(self)
        self.cell.validate(self)

        self.atomic_species.validate()
        self.atomic_positions.validate()
        self.k_points.validate()
        self.cell_parameters.validate()
        # Not Implemented
        # self.occupations.validate()
        # self.constrains.validate()
        # self.atomicforces.validate()


