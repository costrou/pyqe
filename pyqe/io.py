"""
A module for reading the output of 
"""
import re
double_regex = r'[-+]?\d+\.\d+(?:[eE][-+]?\d+)?'
int_regex = '[+-]?\d+'

import struct
import numpy as np
import xml.etree.ElementTree as ET

def read_out_file(output_str):
    """
    This functions takes the output file and breaks it into
    chunks for easier parsing.
    """
    scf_block_regex = re.compile(
        "Self-consistent Calculation"
        ".+?"
        "convergence has been achieved in\s+\d+ iterations",
        re.DOTALL)

    bfgs_regex = re.compile(
        "BFGS Geometry Optimization"
        ".+?"
        "End of BFGS Geometry Optimization",
        re.DOTALL)

    bfgs_block_regex = re.compile(
        "number of scf cycles"
        ".+?"
        "Writing output data file",
        re.DOTALL)

    final_block_regex = re.compile(
        "Final enthalpy"
        ".+?"
        "End final coordinates",
        re.DOTALL)

    header_str = output_str[:scf_block_regex.search(output_str).start()]

    scf_steps = scf_block_regex.findall(output_str)
    bfgs_steps = bfgs_block_regex.findall(output_str)

    if bfgs_regex.search(output_str):
        bfgs_steps.append(final_block_regex.search(output_str).group())
    else:
        bfgs_steps = [""]

    calc_steps = [_ for _ in zip(scf_steps, bfgs_steps)]

    footer_begin = output_str.find("init_run")
    footer_str = output_str[footer_begin:]

    return {"header": read_out_header(header_str),
            "calculation": read_out_calculation(calc_steps)}


def read_out_header(header_str):
    """
    Reader the header of the output file generated by pw.x

    # To shorten regular expressions
    # {0} -> double_regex
    # {1} -> int_regex
    """

    header_values = {
        "bravais-lattice index": (
            r"bravais-lattice index\s+=\s+({1})", float),
        "lattice parameter": (
            r"lattice parameter \(alat\)\s+=\s+({0}) a\.u\.", float),
        "volume": (
            r"unit-cell volume\s+=\s+({0}) \(a\.u\.\)\^3", float),
        "number atoms/cell": (
            r"number of atoms/cell\s+=\s+({1})", int),
        "number atom types": (
            r"number of atomic types\s+=\s+({1})", int),
        "number electrons": (
            r"number of electrons\s+=\s+({0})", float),
        "number of Kohn Sham states": (
            r"number of Kohn Sham states\s*=\s+({1})", int),
        "kinetic-energy cutoff": (
            r"kinetic-energy cutoff\s+=\s+({0})\s+Ry", float),
        "charge density cutoff": (
            r"charge density cutoff\s+=\s+({0})\s+Ry", float),
        "convergence threshold": (
            r"convergence threshold\s+=\s+({0})", float),
        "mixing beta": (
            r"mixing beta\s+=\s+({0})", float),
        "nstep": (
            r"nstep\s+=\s=({1})", int),
        "celldm": (
            r"celldm\(1\)=\s+({0})\s+"
            r"celldm\(2\)=\s+({0})\s+"
            r"celldm\(3\)=\s+({0})\s+"
            r"celldm\(4\)=\s+({0})\s+"
            r"celldm\(5\)=\s+({0})\s+"
            r"celldm\(6\)=\s+({0})", float),
        "crystal axes": (
            r"a\(1\)\s+=\s+\(\s+({0})\s+({0})\s+({0})\s+\)\s+"
            r"a\(2\)\s+=\s+\(\s+({0})\s+({0})\s+({0})\s+\)\s+"
            r"a\(3\)\s+=\s+\(\s+({0})\s+({0})\s+({0})\s+\)\s+", float),
        "reciprocal axes": (
            r"b\(1\)\s+=\s+\(\s+({0})\s+({0})\s+({0})\s+\)\s+"
            r"b\(2\)\s+=\s+\(\s+({0})\s+({0})\s+({0})\s+\)\s+"
            r"b\(3\)\s+=\s+\(\s+({0})\s+({0})\s+({0})\s+\)\s+", float),
        "FFT dimensions": (
            r"FFT dimensions:\s+\(\s+({1}),\s+({1}),\s+({1})\)", int),
    }

    # Find all keypairs
    header = {}
    for key, (regex, _type) in header_values.items():
        match = re.search(regex.format(double_regex, int_regex), header_str)
        if match:
            if len(match.groups()) == 1:
                header.update({key: _type(match.groups()[0])})
            else:
                header.update({key: [_type(_) for _ in match.groups()]})

    # kpoints
    kpoint_regex = "k\(\s+({1})\)\s+=\s+\(\s+({0})\s+({0})\s+({0})\), wk = \s+({0})"
    matches = re.findall(
        kpoint_regex.format(double_regex, int_regex),
        header_str)

    kpoints = []
    for match in matches:
        kpoints.append([match[0], [match[1], match[2], match[3]], match[4]])
        header.update({"kpoints": kpoints})

    return header


def read_out_calculation(bfgs_steps):
    """
    Reads information about the calculation from the output file
    """
    total_energy_regex = r"!\s+total energy\s+=\s+({0}) Ry".format(double_regex)
    volume_regex = r"new unit-cell volume\s=\s+({0}) a\.u\.\^3".format(double_regex)
    lattice_regex = (
        r"CELL_PARAMETERS.*"
        r"\s+({0})\s+({0})\s+({0})"
        r"\s+({0})\s+({0})\s+({0})"
        r"\s+({0})\s+({0})\s+({0})"
    ).format(double_regex)
    ion_position_regex = "([A-Z][a-z]?)\s+({0})\s+({0})\s+({0})".format(double_regex)

    iterations = []
    for scf_block, bgfs_block in bfgs_steps:
        iteration = {}

        match = re.search(total_energy_regex, scf_block)
        iteration.update({"total energy": float(match.group(1))})

        match = re.search(volume_regex, bgfs_block)
        if match:
            iteration.update({"volume": float(match.group(1))})

        match = re.search(lattice_regex, bgfs_block)
        lattice = None
        if match:
            lattice = [float(_) for _ in match.groups(1)]
            iteration.update({"lattice": [lattice[0:3],
                                          lattice[3:6],
                                          lattice[6:9]]})

        match = re.findall(ion_position_regex, bgfs_block)
        if match:
            iteration.update({"ion positions": [[_[0], float(_[1]), float(_[2]), float(_[3])] for _ in match.groups()]})

        iterations.append(iteration)

    calculation = {}
    calculation.update({"iterations": iterations})
    calculation.update(iterations[-1])

    return calculation

def read_charge_density_file(inputfile):
    """
    Reads charge-density.dat file generated by a quantum espresso
    scf/relax/vc-relax run

    Charge Density file format:
    <z.\d+ ... > zaxis_charge_slice </z.\d+>

    zaxis_charge_slice
        12 bytes - header (I dont know what it is yet)
        nr1*nr2 doubles (8 bytes each)
        24 bytes - footer (I dont know what it is yet)

    Why on earth did they make Charge density a binary/xml file?!?
    """
    f = open(inputfile, "rb")
    charge_xml_str = f.read()

    info_regex = b'<INFO nr1="(\d+)" nr2="(\d+)" nr3="(\d+)"/>'

    match = re.search(info_regex, charge_xml_str)
    nr1, nr2, nr3 = [int(_.decode()) for _ in match.groups()]

    nrz_regex = (
        r'<z\.(\d+) type="(\w+)" size="(\d+)" kind="(\d+)">\n'
        r'.{{12}}(.{{{0}}}).{{24}}'
        r'\n    </z\.\d+>\n'
    ).format(nr1*nr2*8)

    matches = re.findall(nrz_regex.encode(), charge_xml_str, re.DOTALL)

    data = []
    for nrz, _type, size, kind, byte_str in matches:
        data += struct.unpack("d"*nr1*nr2, byte_str)

    charge_data = np.array(data, order='F', ndmin=3)
    charge_data.shape = [nr1, nr2, nr3]
    return charge_data

def read_eigenvalue_file(inputfile):
    """Reads the output files for kpoints generated by pw.x
    returns a dictionary of the occupations

    """
    tree = ET.parse(inputfile)
    root = tree.getroot()

    eigenvalues = [float(_) for _ in
                   re.findall(double_regex, root.find('EIGENVALUES').text)]
    occupations = [float(_) for _ in
                   re.findall(double_regex, root.find('OCCUPATIONS').text)]

    return {"eigenvalues": eigenvalues,
            "occupations": occupations}
